{"meta":{"title":"cmsax's blog","subtitle":null,"description":null,"author":"cmsax","url":"https://blog.unoiou.com"},"pages":[{"title":"关于本博客","date":"2018-08-19T15:36:21.000Z","updated":"2018-08-19T16:13:17.079Z","comments":true,"path":"about/index.html","permalink":"https://blog.unoiou.com/about/index.html","excerpt":"","text":"关于我 成长的三个阶段: 写文章自己看, 写博客给大家看, 开源项目. 目前算是第一步吧; 准研究生, 本科社科, CS 学硕, 压力山大; NLP 方向; 目标是成为全栈. 著作权 本博客所有文章均采用 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 进行许可。欢迎转载、使用、重新发布，但务必保留文章署名 CMSAX 包含链接 https://blog.unoiou.com, 不得用于商业目的，基于本文修改后的作品务必以相同的许可发布."},{"title":"","date":"2018-08-20T00:41:31.558Z","updated":"2018-08-20T00:41:16.362Z","comments":true,"path":"google9f140c651b7c56ae.html","permalink":"https://blog.unoiou.com/google9f140c651b7c56ae.html","excerpt":"","text":"google-site-verification: google9f140c651b7c56ae.html"}],"posts":[{"title":"自定义 Docker 镜像","slug":"docker-image-create-build-run-deploy","date":"2018-08-18T05:25:59.293Z","updated":"2018-08-18T05:32:12.239Z","comments":true,"path":"2018/08/18/docker-image-create-build-run-deploy/","link":"","permalink":"https://blog.unoiou.com/2018/08/18/docker-image-create-build-run-deploy/","excerpt":"","text":"日期：2018-07-11 创建自定义 image 本地新建 Dockerfile 本地测试 build 推送到 gitlab 对应 repo 打 tag 推送到 github 公开仓库 自动推送到 dockerhub dockerhub build 使用该 image 本地 pull 或直接 run","categories":[],"tags":[]},{"title":"实体关系抽取 论文阅读笔记","slug":"entity-relation-extraction-notes","date":"2018-08-18T05:25:12.731Z","updated":"2018-08-18T05:48:40.581Z","comments":true,"path":"2018/08/18/entity-relation-extraction-notes/","link":"","permalink":"https://blog.unoiou.com/2018/08/18/entity-relation-extraction-notes/","excerpt":"日期：2018-07-22 Distant supervision for relation extraction without labeled data ACL 2009 任务：现代自动内容抽取任务依赖于手工标注的少量的语料，依赖于标注、领域。需要研究一种不需要标注的方法来避免对领域预料的依赖，这种方法也允许使用任意大小的语料库。","text":"日期：2018-07-22 Distant supervision for relation extraction without labeled data ACL 2009 任务：现代自动内容抽取任务依赖于手工标注的少量的语料，依赖于标注、领域。需要研究一种不需要标注的方法来避免对领域预料的依赖，这种方法也允许使用任意大小的语料库。 我们的工作：引入外部知识库，使用远程监督来进行关系抽取。 实验数据：Freebase, Wikipedia 文章 方法的基本假设：任一句子中如果出现了知识库中已知的关系的实体，那么这个句子极有可能表示知识库中的这种关系。 特征选择：词法、句法、语义特征。 实验部分：使用 Held-Out 留出法、人工评估两种方式进行评估。 Trick：构造负例，随机采样不在知识库中的实体对。 Modeling relations and their mentions without labeled text ECML 2010 在一些的情况下 这篇文章的数据集是很重要的。 背景：已有一些采用远程监督来进行实体关系抽取的方法，这些方法依赖于假设：任一句子中如果出现了知识库中已知的关系的实体，那么这个句子就表示知识库中的这种关系。 问题：我们认为上述方法会产生噪音数据，从而降低准确率，尤其是知识库与要处理的语料库关系不是很紧密的时候。 我们的工作：用两个方法来解决上述问题，(1) 采用因子图来显式地给 两个实体是否有关系 以及 在给定的句子中是否存在关系 这两个问题建模。 (2) 不使用有关哪一个句子中存在知识库中的关系这一先验知识，采用驱动限制的半监督来训练模型。 实验数据：Freebase, New York Times 文章 方法的基本假设：如果给定实体在知识库中存在关系，那么包含这些实体的句子集合中至少有一个句子可能表示这个关系。 实验部分：使用 Held-Out 留出法、人工评估两种方法进行评估。 基本概念精确率 Precision 和 召回率 Recall 更形象的图 此外，准确率 Accuracy 为 (TP + TF) / (TP + FP + TN + FN) MAP, MLE最大后验概率 MAP Maximum a Posteriori Estimation 最大似然估计 MLE Maximum Likelihood Estimation 模型已定，参数未知。 https://blog.csdn.net/u011508640/article/details/72815981 Ground Truth正确的标记 LRLogistic Regression Perceptron感知机","categories":[],"tags":[]},{"title":"测试驱动开发入门指南","slug":"tdd-guide","date":"2018-08-18T05:24:46.487Z","updated":"2018-08-19T15:10:20.449Z","comments":true,"path":"2018/08/18/tdd-guide/","link":"","permalink":"https://blog.unoiou.com/2018/08/18/tdd-guide/","excerpt":"日期：2018-07-09 [TOC] TDD 的由来 上图是典型的瀑布式（V 测试模型）开发流程，只有在完成了编码之后才会进入代码的 Quality Assurance 阶段，开始各种测试。需求易变，测试过晚是瀑布式开发流程容易遇到的问题。更早、更频繁地进行测试，以在问题的修复成本不太高时提早将其解决，同时以更快的速度开发更高质量的代码，已经是软件开发的要求。","text":"日期：2018-07-09 [TOC] TDD 的由来 上图是典型的瀑布式（V 测试模型）开发流程，只有在完成了编码之后才会进入代码的 Quality Assurance 阶段，开始各种测试。需求易变，测试过晚是瀑布式开发流程容易遇到的问题。更早、更频繁地进行测试，以在问题的修复成本不太高时提早将其解决，同时以更快的速度开发更高质量的代码，已经是软件开发的要求。 下图是测试驱动开发（TDD Test Driven Development）的工作流程 TDD 的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。 需求是软件开发过程中最不好明确描述、同时也是易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。 测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。我们在开发之前，先写的详细需求文档、测试用例等都是在做这部分的工作。 通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。 开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。 快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重 bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。 当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位 bug。而迅速发现、定位 bug 是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位 bug 提供了条件。 TDD 原则编写文档编写详细的关于代码的使用需求文档、测试用例，对软件的功能、接口、过程、测试进行详细描述。 测试隔离不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。 一顶帽子开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节（比如突然想到加一个新的炫酷的功能），保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。 测试列表需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。避免疏漏，也避免干扰当前进行的工作。 测试驱动这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。 先写断言测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。 可测试性功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等，尽可能解耦。 及时重构无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。 重构：在保证代码运行正常的前提下，提高代码的可维护性、健壮性、性能。方法包括：解耦方法、降低复杂度、小就是美、测试私有方法、 小步前进敏捷技术并非只适合小项目，其对大型项目更有意义。小步小步地写软件比大步完成更具生产力。 软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。 对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。 这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成。本来感觉很多特性需要增加，很快就会看到没有几个了。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感） 最小可用发布最小可用产品（minimum viable product），并基于客户反馈快速调整。 如何进行测试测试范围、粒度要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。 测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。 测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着 bug 的出现，根据 bug 补齐相关的测试用例即可。 小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类 A 使用了类 B、C，就应该在编写 A 使用 B、C 功能的测试代码前，完成对 B、C 的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。 如何编写测试用例测试用例的编写就用上了传统的测试技术。 操作过程尽量模拟正常使用的过程，先写功能测试。 全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。 测试数据尽量包括：真实数据、边界数据。 测试语句和测试数据应该尽量简单，容易理解。 为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。 如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。 测试代码应当十分简单，如果过于复杂，就应该继续分解。 不测试常量。 简单的测试分类功能测试又称端到端测试（End to End Test）、验收测试（Acceptance Test）等，是站在用户的角度，从系统外部观察/描述应用是如何运行的，也是一种黑箱测试（Black Box Test）。 从 TDD 一开始，就是在用户故事的指导下开始功能测试，进而开始单元测试。而关于用户故事通常包含 角色、功能、价值 这三个要素。优秀的用户故事应当是独立的、可讨论的、有价值的、可估算的、小的、可测试的。当故事很大时，我们需要对故事进行拆分。 不应让用户故事过早的设计用户界面。 从客户的较都编写故事。 故事好不好、如何更改、哪个故事更重要，客户说了算。 单元测试单元测试是从程序员的角度编写的。它确保某一个特定方法成功执行一系列特定的任务。每个测试都确保只要给定输入，方法将输出预期的结果。 集成测试单元测试只能验证小块代码的功能，因此需要集成测试来验证更高级的功能。集成测试是指在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行测试。 比如某个方法需要访问数据库，那么就一定是进行集成测试。 其他分类方法 盒子类测试 黑盒测试黑盒测试，指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。 它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。 白盒测试白盒测试，指的是把盒子盖子打开，去研究里面的源代码和程序结果。 它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作 灰盒测试灰盒测试介于黑盒测试与白盒测试之间。 可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。 其它测试 冒烟测试是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。 引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件 的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。 回归测试回归测试是指修改了旧代码后，重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误。 回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然，回归也是一个循环的过程，如果回归的问题通不过，则需要开发人员修改后再次进行回归，直到通过为止。 随机测试是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。 随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。其实随机测试更专业的升级版叫 探索性测试。 探索性测试探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。 探索性测试应该是未来测试领域的一个方向。 安全测试安全测试是在 IT 软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。 安全测试也在越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其对于互联网产品最容易遭受各种安全攻击。 TDD 与 BDD 的区别 以 Javascript 为例原文链接：https://joshldavis.com/2013/05/27/difference-between-TDD-and-bdd/ 翻译：cmsax unoiou.com 如果您不断更新最新的软件开发实践, 您就会听到测试驱动开发 (TDD)和行为驱动开发 (BDD)的可能性。这篇文章意在解释每个练习的含义, 提供示例, 然后对比两者。让我们挖掘, 看看我们学到了什么。 测试驱动的开发当我第一次听说 TDD 的时候, 这个想法似乎很简单。只需做一个小词 swizzling, 显然 TDD 是当你有测试, 驱动你的软件开发。 如果我们要进一步拆分 TDD 的定义, 我们会发现它通常被分成五个不同的阶段: 首先, 开发人员编写一些测试。 然后, 开发人员运行这些测试, 并且 (显然) 它们失败, 因为这些功能都没有实际实现。 接下来, 开发人员实际上在代码中实现这些测试。 如果开发人员编写他们的代码很好, 那么在下一阶段他们将看到他们的测试通过。 然后, 开发人员可以重构他们的代码, 添加注释并将其清理干净, 因为开发人员知道, 如果新代码破坏了某些内容, 那么测试将通过失败而成为警报。 只要开发人员有更多的功能可添加, 循环就可以继续。下面给出一个流程图: 测试驱动的开发流程图 例子让我们看看一个开发人员如何做到这一点的例子。本文的完整源代码位于此存储库中: TDD vs bdd。可以随意克隆它, 并通过发出命令来运行它。npm install &amp;&amp; grunt 假设开发人员想要编写一个函数来做一些简单的事情, 比如计算一个阶乘 (显然是一个相当做作的例子, 但它会告诉我们 TDD 和 BDD 之间的区别)。TDD 所规定的正常方法是使用函数, 然后断言结果满足一定的值。 在这个例子中, 我们将使用一个叫做Mocha 发音：摩卡的 JavaScript 测试框架。测试可能类似于以下内容: 1234567891011121314151617181920212223242526var assert = require('assert'), factorial = require('../index')suite('Test', function() &#123; setup(function() &#123; // Create any objects that we might need &#125;) suite('#factorial()', function() &#123; test('equals 1 for sets of zero length', function() &#123; assert.equal(1, factorial(0)) &#125;) test('equals 1 for sets of length one', function() &#123; assert.equal(1, factorial(1)) &#125;) test('equals 2 for sets of length two', function() &#123; assert.equal(2, factorial(2)) &#125;) test('equals 6 for sets of length three', function() &#123; assert.equal(6, factorial(3)) &#125;) &#125;)&#125;) 由于函数尚未写入, 测试将明显失败。因此, 让我们写的功能, 以满足测试。它可能看起来像这样: 123456module.exports = function(n) &#123; if (n &lt; 0) return NaN if (n === 0) return 1 return n * factorial(n - 1)&#125; 现在, 如果我们运行测试, 我们可以看到, 他们都通过 TDD 就是这样工作的。现在让我们来看看 BDD, 看看它是如何不同的。 行为驱动的开发好吧, 那么你问的 BDD 是什么？这就是有点模糊的地方。有些人会说它与 TDD 类似, 其他的则会说它只是 TDD, 但有更好的指导方针, 甚至完全不同的开发方法。 不管实际的定义是什么, 它并不重要。最重要的是要知道 BDD 是为了消除 TDD 可能导致的问题. 与 TDD 相比, BDD 是当我们编写行为 &amp; 规范, 然后驱动我们的软件开发。行为 &amp; 规范可能看起来非常类似于测试, 但差异是非常微妙和重要的。 例子让我们来看看前面的例子, 写一个函数来计算一个数字的阶乘。 123456789101112131415161718192021222324252627282930var assert = require('assert'), factorial = require('../index')describe('Test', function() &#123; before(function() &#123; // Stuff to do before the tests, like imports, what not &#125;) describe('#factorial()', function() &#123; it('should return 1 when given 0', function() &#123; factorial(0).should.equal(1) &#125;) it('should return 1 when given 1', function() &#123; factorial(1).should.equal(1) &#125;) it('should return 2 when given 2', function() &#123; factorial(2).should.equal(2) &#125;) it('should return 6 when given 3', function() &#123; factorial(3).should.equal(6) &#125;) &#125;) after(function() &#123; // Anything after the tests have finished &#125;)&#125;) 主要的区别就在于措辞/写法。BDD 使用更详细的样式, 以便可以像句子一样阅读它。 这就是我说 BDD 消除 TDD 可能导致的问题的意思。阅读你的测试就像一个句子的能力是一个认知上的转变, 你将如何思考你的测试。论点是, 如果你能流畅地阅读你的测试, 你自然会写出更好、更全面的测试。 虽然这个例子很简单, 没有完全地阐述 BDD 测试应该更注重功能, 而不是实际的结果。通常您会听到 BDD 是为了帮助设计软件, 而不是像 TDD 打算做的那样测试它。 TDD vs BDDTDD 和 BDD 之间的选择是复杂的。这取决于是否有一个适当的测试框架为您的给定的目标语言, 什么您的同事是舒适的, 有时其他因素。 一些人认为 BDD 总是比 TDD 更好, 因为它有可能消除使用 TDD 时可能出现的问题。 BDD 的关键是它可以防止问题，但并不是保证不出问题。代码组织差、设计方法不好等问题仍将持续存在。 你会有更低的概率写出糟糕的测试, 从而让软件具有更健壮的功能。 结论两种风格都不比另一种好, 它真的取决于人。一个知道如何编写伟大的 TDD 测试的人, 就像知道如何编写伟大的 BDD 测试的人一样少。如果您发现自己使用 TDD 编写不完整的测试, 并希望设计更好的软件？然后给 BDD 一个机会。如果您对 TDD 和 BDD 都是新的, 我建议您首先学习和使用 TDD。这两种样式中最重要的部分是, 它强制您为代码编写测试。 我不是任何方法的 TDD 或 BDD 专家。我只是不知道自己的差异, 所以我调查了一下, 这是我想到了。这篇文章中的示例代码再次位于此存储库中: TDD vs bdd。","categories":[],"tags":[]},{"title":"Electron 功能测试指南","slug":"electron-functional-test-guide","date":"2018-08-18T05:24:08.902Z","updated":"2018-08-18T05:48:33.758Z","comments":true,"path":"2018/08/18/electron-functional-test-guide/","link":"","permalink":"https://blog.unoiou.com/2018/08/18/electron-functional-test-guide/","excerpt":"日期：2018-07-30 [TOC] 概述在单元测试中，我们用到的是 Vue 官方给的 vue-test-utils 来控制、获取组件的运行状态，但在功能测试中，我们使用 Electron 官方提供的 Spectron 库。Spectron 暴露了以下十分有用的属性：","text":"日期：2018-07-30 [TOC] 概述在单元测试中，我们用到的是 Vue 官方给的 vue-test-utils 来控制、获取组件的运行状态，但在功能测试中，我们使用 Electron 官方提供的 Spectron 库。Spectron 暴露了以下十分有用的属性： client 属性，该属性是 WebdriverIO 中的 browser 对象，因此可以使用完全的 WebdriverIO 的 API 来操作、获取页面上的内容，实现譬如选择器、设置某一个 input 标签的值、设置某一个元素的属性、点击、滚动的诸多操作。 electron 属性，该属性可以看作对 electron 的引用，可以直接通过它来操作完整的 electron API 比如进程间通信、剪贴板操作等。 还有更多的属性，可以在其官方仓库中查看。 我们如何编写功能测试为确保每一个功能测试均有独立的环境，测试代码中包含了 beforeEach, afterEach这两个类似于 python 中的 startUp, tearDown的函数。 我们只需在代码目录的 ./test/e2e/specs/ 下新建名为 TEST_NAME.spec.js 的文件，并粘贴以下代码片段即可建立一个新的部分功能测试。 在测试中，项目使用的测试断言库是 chai，具体的 BDD 风格的断言参考官方文档即可。比如，我们期望页面上的某一个元素的值为 N 可以写成这样：先获取元素的值 value，然后 expect(value).to.eq(expectValue) 123456789101112131415161718import utils from '../utils'describe('Test handle stock pool indicators', function() &#123; beforeEach(utils.beforeEach) afterEach(utils.afterEach) it('can add normal stock pool indicator', () =&gt; &#123; let client = this.app.client // do something expect(SOMETHIGN).to.be.or.eq(SOMETHING) &#125;) it('can validate wrong stock pool indicator with non-numeric backtest amount', () =&gt; &#123; let client = this.app.client // do something expect(SOMETHIGN).to.be.or.eq(SOMETHING) &#125;)&#125;) 如何运行功能测试采用 npm 进行包管理的 js 程序在根目录都有一个 package.json 文件，其中 scripts中定义了可以执行的命令。对于其中的命令，在命令行/powershell 中运行 npm run SPECIFIC_SCRIPTNAME 即可运行。 如，功能测试 npm run e2e","categories":[],"tags":[]},{"title":"Electron 持续集成指南","slug":"electron-continuous-integration-guide","date":"2018-08-18T05:23:25.219Z","updated":"2018-08-19T15:11:33.342Z","comments":true,"path":"2018/08/18/electron-continuous-integration-guide/","link":"","permalink":"https://blog.unoiou.com/2018/08/18/electron-continuous-integration-guide/","excerpt":"日期：2018-07-06 [TOC] 背景我们团队推崇 TDD 和 Auto DevOps ,对于每一个项目,我们首先需要做的事情是建立规范的工作流程. 我们已有的项目托管在私有 Gitlab 上, 采用 Gitlab runner 在 Kubernetes docker 集群上运行我们的服务, 包括自动化测试, 部署以及运维. 我们的开发遵循 TDD 原则, 项目中最核心的是需求文档和测试这两个部分. 自动化测试能够为代码审查提供参考, Auto DevOps 能够让我们的项目迭代更加迅速. 编写测试, 测试用例以及可测试的代码都十分考验开发者的能力. 我们的要求是: 分支全覆盖, 耦合降到最低, 测试代码尽量简短. 前端是我们最近探索的一个方向, 相关的工作流程和技术都还不熟悉, 而我刚加入这个团队(实习), 对前端有一点了解, 因此探索前端这一任务就交给我了. 对于前端开发, 我们需要怎样来进行需求分析, 用户故事是什么, 应该怎么写, 测试应该怎么写, 框架有哪些 这些问题我们都需要解决.","text":"日期：2018-07-06 [TOC] 背景我们团队推崇 TDD 和 Auto DevOps ,对于每一个项目,我们首先需要做的事情是建立规范的工作流程. 我们已有的项目托管在私有 Gitlab 上, 采用 Gitlab runner 在 Kubernetes docker 集群上运行我们的服务, 包括自动化测试, 部署以及运维. 我们的开发遵循 TDD 原则, 项目中最核心的是需求文档和测试这两个部分. 自动化测试能够为代码审查提供参考, Auto DevOps 能够让我们的项目迭代更加迅速. 编写测试, 测试用例以及可测试的代码都十分考验开发者的能力. 我们的要求是: 分支全覆盖, 耦合降到最低, 测试代码尽量简短. 前端是我们最近探索的一个方向, 相关的工作流程和技术都还不熟悉, 而我刚加入这个团队(实习), 对前端有一点了解, 因此探索前端这一任务就交给我了. 对于前端开发, 我们需要怎样来进行需求分析, 用户故事是什么, 应该怎么写, 测试应该怎么写, 框架有哪些 这些问题我们都需要解决. 需求 客户需要一个客户端来简化一些操作, 他使用的是 Windows 10 系统. 在完成安全审查后, 项目将上线. 我们要在 docker 容器中运行我们的测试和部署任务, 它没有 GUI. 商业项目, 不开源. 我们的解决方案考虑到开发的便捷以及未来在 Web 上为用户提供服务, 我们选择了 Electron-Vue 这一脚手架来开始我们的项目. Electron 官方文档中给出了用于功能测试的 Spectron 框架, 这一框架暴露了 Electron 的完整 API, WebDriverIO 的完整 API. Vue 的单文件组件以及官方的 Vue-test-utils 也为组件的单元测试提供了丰富的支持. Electron-Vue 脚手架中选择了 Karma, Chai.js 这两个测试套件, 其中 Karma 是测试运行器和监视器, Chai.js 是断言库. 脚手架中已经配置好了测试, 在有 GUI 的系统中, 我们可以直接运行项目根目录下的 package.json 中的命令来运行测试. 因此, 我们的第一个任务是创建一个能够运行测试和打包的 docker 镜像. 任务 1: 构建用于测试和打包的 docker 镜像docker 使用请参考官方文档, 30 分钟以内即可上手. 通过在 linux 中跑一下 Electron 及其测试和查看网上的资源, 我们发现它需要这些依赖: Xvfb: Xvfb or X virtual framebuffer is a display server implementing the X11 display server protocol. In contrast to other display servers, Xvfb performs all graphical operations in virtual memory without showing any screen output. wine32: 32 位的 node.js: V8 在踩了很多坑后, 我们基于 Fedora wine32 构建了一个 docker 镜像, 它主要包括: 最新的 LTS 版本的 npm 和 Node.js Wine32 Xvfb 及其依赖的诸多框架 在这一镜像中, 我们成功完成了测试和 Electron 用于 Windows 平台应用的打包. 使用如下命令可以拉取这一镜像: 1docker pull windworship/npm-image 接下来, 我们需要编写一个 gitlab-ci 配置文件来在 gitlab-runner 上自动化测试以及打包. 任务 2: Gitlab-CI 配置gitlab-ci 使用方法请参考官方文档, 30 分钟内即可上手. 我们不用更改脚手架中原来的文件, 运行一个最简可行的测试和打包即可. 我们主要有 2 个任务: 测试和打包. 在测试这一阶段, 我们需要设置一个虚拟显示器的环境变量. 此外, 由于推送到 gitlab 上的项目不包括 node_modules 这一文件夹, 我们也需要安装 npm 相关包. 在完成了这两个任务后, 我们开始我们的测试. 我们发现, 如果在每一次测试中都使用 npm 重新安装一次依赖包会耗费大量的时间, 因此在 CI 文件中, 我们需要为 node_modules 这一文件夹设置缓存. 在功能测试部分, 我们需要查看程序运行的截图, 而不是仅仅用代码检查 CSS 或者文字在页面上的出现情况, 因此需要设置 artifacts 用于下载程序测试过程的截图. 而在下载了第一个截图后, 我们发现程序中中文显示是乱码的, 需要安装中文语言包. 以上是我们需要在 before_script 和 cache 中做的事情. 在测试阶段, 代码风格审查使用 eslint , 配置 vue 和 standard.js 的插件, 运行 package.json 中的命令开始测试, 命令十分简单. 对于程序的部署, 我们自建了应用更新服务器. 这一阶段的命令也十分简单. 这样, 我们就完成了 Electron 应用在 gitlab 上最简可用的持续集成解决方案. 接下来, 我们需要开始编写测试和程序代码. 任务 3: 编写测试代码 TDD: Test driven development. BDD: Behavior driven development. 相关介绍可参考我的上一篇博客 测试驱动开发入门指南. 由于缺乏经验, 我们决定先编写一个只能进行 monkey test 的可运行的程序, 然后写一些简单的单元测试和功能测试. 虽然这违背了 TDD 的原则. 在之前的项目中, 我们使用的是 TDD 风格的断言, 最常用的是各种 assert , 而在前端, 我们发现 Chai.js 为我们提供的 BDD 风格的断言似乎更受欢迎. BDD 风格的断言看起来类似自然语言, 比如 expect(a).to.deep.eq(b) 或者 ()().then().should.not.be.undefined 这种. 在 Vue 的单元测试中, 似乎最小可测单元就是单文件组件的状态, 方法, 数据以及生命周期钩子等. 我们发现, 对一些组件的方法的测试更像是一个集成测试, 对于这种方法, 我们需要在符合 Vue 规范的前提下, 将其尽量解耦. 在功能测试中, 由于分支过多, 我们仅对用户故事中描述的行为进行测试, 而将分支的测试在组件的单元测试中覆盖. 功能测试时, 由于用户的行为是连续, 同步进行的, 因此需要使用 async / await 来确保测试代码依次执行. 此外, 还需要设置超时时间, 以避免因测试超时而出错. 功能测试需要用到 WebDriverIO 以及 Electron 的 API, 写之前先总体浏览一下, 确定测试该怎么做. 不要在测试中捕获异常, 即使你在 debug 或者你只是打印了一下输出然后将异常再次抛出. 😄 尤其是 then,...catch 这种写法, 后面的 catch 就不需要了. 在写单元测试时, 对于测试的描述不应当仅使用自然语言, 而应当直接给出测试的组件和方法名. 在功能测试中也应当为每一步添加注释, 同时遵循用户故事中的行为.这对于审查你的代码的人非常重要. 例如: 12345678910111213141516171819202122232425// 单元测试 非常糟糕的测试describe('App.vue', () =&gt; &#123; it('can concate error when error updates.', () =&gt; &#123; ...// 单元测试 很好的测试describe('BasicOption.vue', () =&gt; &#123; it('methods: queryIndicatorNotes()', () =&gt; &#123; ...// 功能测试describe('Main function test', function () &#123; beforeEach(utils.beforeEach) afterEach(utils.afterEach) it('can confirm data and write JSON string to clipboard', async function () &#123; this.timeout(15000) let browser = this.app.client let electron = this.app.electron electron.clipboard.writeText('') // 行为注释: What's new await browser.getText('.el-notification__content').then(result =&gt; &#123; expect(result.length).to.least(5) &#125;) ... 实际运行效果流水线: 单元测试结果:从一开始的平均 40% 多慢慢提上来的… 功能测试结果: 欢迎在评论中给出优化建议. 转载请注明出处. 以上.","categories":[],"tags":[]}]}