{"meta":{"title":"cmsax's blog","subtitle":null,"description":null,"author":"cmsax","url":"https://blog.cmsax.com"},"pages":[],"posts":[{"title":"","slug":"docker-image-create-build-run-deploy","date":"2018-08-18T05:25:59.293Z","updated":"2018-07-11T02:21:17.062Z","comments":true,"path":"2018/08/18/docker-image-create-build-run-deploy/","link":"","permalink":"https://blog.cmsax.com/2018/08/18/docker-image-create-build-run-deploy/","excerpt":"","text":"自定义 Docker image作者：蔡明师 日期：2018-07-11 创建自定义 image 本地新建 Dockerfile 本地测试 build 推送到 gitlab 对应 repo 打 tag 推送到 github 公开仓库 自动推送到 dockerhub dockerhub build 使用该 image 本地 pull 或直接 run","categories":[],"tags":[]},{"title":"","slug":"entity-relation-extraction-notes","date":"2018-08-18T05:25:12.731Z","updated":"2018-07-22T15:23:23.286Z","comments":true,"path":"2018/08/18/entity-relation-extraction-notes/","link":"","permalink":"https://blog.cmsax.com/2018/08/18/entity-relation-extraction-notes/","excerpt":"","text":"实体关系抽取 论文阅读笔记作者：蔡明师 日期：2018-07-22 Distant supervision for relation extraction without labeled data ACL 2009 任务：现代自动内容抽取任务依赖于手工标注的少量的语料，依赖于标注、领域。需要研究一种不需要标注的方法来避免对领域预料的依赖，这种方法也允许使用任意大小的语料库。 我们的工作：引入外部知识库，使用远程监督来进行关系抽取。 实验数据：Freebase, Wikipedia 文章 方法的基本假设：任一句子中如果出现了知识库中已知的关系的实体，那么这个句子极有可能表示知识库中的这种关系。 特征选择：词法、句法、语义特征。 实验部分：使用 Held-Out 留出法、人工评估两种方式进行评估。 Trick：构造负例，随机采样不在知识库中的实体对。 Modeling relations and their mentions without labeled text ECML 2010 在一些的情况下 这篇文章的数据集是很重要的。 背景：已有一些采用远程监督来进行实体关系抽取的方法，这些方法依赖于假设：任一句子中如果出现了知识库中已知的关系的实体，那么这个句子就表示知识库中的这种关系。 问题：我们认为上述方法会产生噪音数据，从而降低准确率，尤其是知识库与要处理的语料库关系不是很紧密的时候。 我们的工作：用两个方法来解决上述问题，(1) 采用因子图来显式地给 两个实体是否有关系 以及 在给定的句子中是否存在关系 这两个问题建模。 (2) 不使用有关哪一个句子中存在知识库中的关系这一先验知识，采用驱动限制的半监督来训练模型。 实验数据：Freebase, New York Times 文章 方法的基本假设：如果给定实体在知识库中存在关系，那么包含这些实体的句子集合中至少有一个句子可能表示这个关系。 实验部分：使用 Held-Out 留出法、人工评估两种方法进行评估。 基本概念精确率 Precision 和 召回率 Recall 更形象的图 此外，准确率 Accuracy 为 (TP + TF) / (TP + FP + TN + FN) MAP, MLE最大后验概率 MAP Maximum a Posteriori Estimation 最大似然估计 MLE Maximum Likelihood Estimation 模型已定，参数未知。 https://blog.csdn.net/u011508640/article/details/72815981 Ground Truth正确的标记 LRLogistic Regression Perceptron感知机","categories":[],"tags":[]},{"title":"","slug":"tdd-guide","date":"2018-08-18T05:24:46.487Z","updated":"2018-07-11T16:03:40.391Z","comments":true,"path":"2018/08/18/tdd-guide/","link":"","permalink":"https://blog.cmsax.com/2018/08/18/tdd-guide/","excerpt":"","text":"测试驱动开发入门指南作者：蔡明师 日期：2018-07-09 [TOC] TDD 的由来 上图是典型的瀑布式（V测试模型）开发流程，只有在完成了编码之后才会进入代码的 Quality Assurance 阶段，开始各种测试。需求易变，测试过晚是瀑布式开发流程容易遇到的问题。更早、更频繁地进行测试，以在问题的修复成本不太高时提早将其解决，同时以更快的速度开发更高质量的代码，已经是软件开发的要求。 下图是测试驱动开发（TDD Test Driven Development）的工作流程 TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。 需求是软件开发过程中最不好明确描述、同时也是易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。 测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。我们在开发之前，先写的详细需求文档、测试用例等都是在做这部分的工作。 通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。 开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。 快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。 当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。 TDD 原则编写文档编写详细的关于代码的使用需求文档、测试用例，对软件的功能、接口、过程、测试进行详细描述。 测试隔离不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。 一顶帽子开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节（比如突然想到加一个新的炫酷的功能），保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。 测试列表需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。避免疏漏，也避免干扰当前进行的工作。 测试驱动这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。 先写断言测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。 可测试性功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等，尽可能解耦。 及时重构无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。 重构：在保证代码运行正常的前提下，提高代码的可维护性、健壮性、性能。方法包括：解耦方法、降低复杂度、小就是美、测试私有方法、 小步前进敏捷技术并非只适合小项目，其对大型项目更有意义。小步小步地写软件比大步完成更具生产力。 软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。 对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。 这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成。本来感觉很多特性需要增加，很快就会看到没有几个了。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感） 最小可用发布最小可用产品（minimum viable product），并基于客户反馈快速调整。 如何进行测试测试范围、粒度要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。 测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。 测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。 小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该在编写A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。 如何编写测试用例测试用例的编写就用上了传统的测试技术。 操作过程尽量模拟正常使用的过程，先写功能测试。 全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。 测试数据尽量包括：真实数据、边界数据。 测试语句和测试数据应该尽量简单，容易理解。 为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。 如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。 测试代码应当十分简单，如果过于复杂，就应该继续分解。 不测试常量。 简单的测试分类功能测试又称端到端测试（End to End Test）、验收测试（Acceptance Test）等，是站在用户的角度，从系统外部观察/描述应用是如何运行的，也是一种黑箱测试（Black Box Test）。 从 TDD 一开始，就是在用户故事的指导下开始功能测试，进而开始单元测试。而关于用户故事通常包含 角色、功能、价值 这三个要素。优秀的用户故事应当是独立的、可讨论的、有价值的、可估算的、小的、可测试的。当故事很大时，我们需要对故事进行拆分。 不应让用户故事过早的设计用户界面。 从客户的较都编写故事。 故事好不好、如何更改、哪个故事更重要，客户说了算。 单元测试单元测试是从程序员的角度编写的。它确保某一个特定方法成功执行一系列特定的任务。每个测试都确保只要给定输入，方法将输出预期的结果。 集成测试单元测试只能验证小块代码的功能，因此需要集成测试来验证更高级的功能。集成测试是指在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行测试。 比如某个方法需要访问数据库，那么就一定是进行集成测试。 其他分类方法 盒子类测试 黑盒测试黑盒测试，指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。 它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。 白盒测试白盒测试，指的是把盒子盖子打开，去研究里面的源代码和程序结果。 它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作 灰盒测试灰盒测试介于黑盒测试与白盒测试之间。 可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。 其它测试 冒烟测试是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。 引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件 的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。 回归测试回归测试是指修改了旧代码后，重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误。 回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然，回归也是一个循环的过程，如果回归的问题通不过，则需要开发人员修改后再次进行回归，直到通过为止。 随机测试是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。 随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。其实随机测试更专业的升级版叫 探索性测试。 探索性测试探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。 探索性测试应该是未来测试领域的一个方向。 安全测试安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。 安全测试也在越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其对于互联网产品最容易遭受各种安全攻击。 TDD 与 BDD 的区别 以 Javascript 为例原文链接：https://joshldavis.com/2013/05/27/difference-between-TDD-and-bdd/ 翻译：蔡明师 如果您不断更新最新的软件开发实践, 您就会听到测试驱动开发 (TDD)和行为驱动开发 (BDD)的可能性。这篇文章意在解释每个练习的含义, 提供示例, 然后对比两者。让我们挖掘, 看看我们学到了什么。 测试驱动的开发当我第一次听说 TDD 的时候, 这个想法似乎很简单。只需做一个小词 swizzling, 显然 TDD 是当你有测试, 驱动你的软件开发。 如果我们要进一步拆分 TDD 的定义, 我们会发现它通常被分成五个不同的阶段: 首先, 开发人员编写一些测试。 然后, 开发人员运行这些测试, 并且 (显然) 它们失败, 因为这些功能都没有实际实现。 接下来, 开发人员实际上在代码中实现这些测试。 如果开发人员编写他们的代码很好, 那么在下一阶段他们将看到他们的测试通过。 然后, 开发人员可以重构他们的代码, 添加注释并将其清理干净, 因为开发人员知道, 如果新代码破坏了某些内容, 那么测试将通过失败而成为警报。 只要开发人员有更多的功能可添加, 循环就可以继续。下面给出一个流程图: 测试驱动的开发流程图 例子让我们看看一个开发人员如何做到这一点的例子。本文的完整源代码位于此存储库中: TDD vs bdd。可以随意克隆它, 并通过发出命令来运行它。npm install &amp;&amp; grunt 假设开发人员想要编写一个函数来做一些简单的事情, 比如计算一个阶乘 (显然是一个相当做作的例子, 但它会告诉我们 TDD 和 BDD 之间的区别)。TDD 所规定的正常方法是使用函数, 然后断言结果满足一定的值。 在这个例子中, 我们将使用一个叫做Mocha 发音：摩卡的 JavaScript 测试框架。测试可能类似于以下内容: 123456789101112131415161718192021222324252627var assert = require('assert'),factorial = require('../index');suite('Test', function ()&#123; setup(function ()&#123; // Create any objects that we might need &#125;); suite('#factorial()', function ()&#123; test('equals 1 for sets of zero length', function ()&#123; assert.equal(1, factorial(0)); &#125;); test('equals 1 for sets of length one', function ()&#123; assert.equal(1, factorial(1)); &#125;); test('equals 2 for sets of length two', function ()&#123; assert.equal(2, factorial(2)); &#125;); test('equals 6 for sets of length three', function ()&#123; assert.equal(6, factorial(3)); &#125;); &#125;);&#125;); 由于函数尚未写入, 测试将明显失败。因此, 让我们写的功能, 以满足测试。它可能看起来像这样: 123456module.exports = function (n) &#123; if (n &lt; 0) return NaN; if (n === 0) return 1; return n * factorial(n - 1);&#125;; 现在, 如果我们运行测试, 我们可以看到, 他们都通过 TDD 就是这样工作的。现在让我们来看看 BDD, 看看它是如何不同的。 行为驱动的开发好吧, 那么你问的 BDD 是什么？这就是有点模糊的地方。有些人会说它与 TDD 类似, 其他的则会说它只是 TDD, 但有更好的指导方针, 甚至完全不同的开发方法。 不管实际的定义是什么, 它并不重要。最重要的是要知道 BDD 是为了消除 TDD 可能导致的问题. 与 TDD 相比, BDD 是当我们编写行为 &amp; 规范, 然后驱动我们的软件开发。行为 &amp; 规范可能看起来非常类似于测试, 但差异是非常微妙和重要的。 例子让我们来看看前面的例子, 写一个函数来计算一个数字的阶乘。 123456789101112131415161718192021222324252627282930var assert = require('assert'),factorial = require('../index');describe('Test', function ()&#123; before(function()&#123; // Stuff to do before the tests, like imports, what not &#125;); describe('#factorial()', function ()&#123; it('should return 1 when given 0', function ()&#123; factorial(0).should.equal(1); &#125;); it('should return 1 when given 1', function ()&#123; factorial(1).should.equal(1); &#125;); it('should return 2 when given 2', function ()&#123; factorial(2).should.equal(2); &#125;); it('should return 6 when given 3', function ()&#123; factorial(3).should.equal(6); &#125;); &#125;); after(function () &#123; // Anything after the tests have finished &#125;);&#125;); 主要的区别就在于措辞/写法。BDD 使用更详细的样式, 以便可以像句子一样阅读它。 这就是我说 BDD 消除 TDD 可能导致的问题的意思。阅读你的测试就像一个句子的能力是一个认知上的转变, 你将如何思考你的测试。论点是, 如果你能流畅地阅读你的测试, 你自然会写出更好、更全面的测试。 虽然这个例子很简单, 没有完全地阐述 BDD 测试应该更注重功能, 而不是实际的结果。通常您会听到 BDD 是为了帮助设计软件, 而不是像 TDD 打算做的那样测试它。 TDD vs BDDTDD 和 BDD 之间的选择是复杂的。这取决于是否有一个适当的测试框架为您的给定的目标语言, 什么您的同事是舒适的, 有时其他因素。 一些人认为 BDD 总是比 TDD 更好, 因为它有可能消除使用 TDD 时可能出现的问题。 BDD 的关键是它可以防止问题，但并不是保证不出问题。代码组织差、设计方法不好等问题仍将持续存在。 你会有更低的概率写出糟糕的测试, 从而让软件具有更健壮的功能。 结论两种风格都不比另一种好, 它真的取决于人。一个知道如何编写伟大的 TDD 测试的人, 就像知道如何编写伟大的 BDD 测试的人一样少。如果您发现自己使用 TDD 编写不完整的测试, 并希望设计更好的软件？然后给 BDD 一个机会。如果您对 TDD 和 BDD 都是新的, 我建议您首先学习和使用 TDD。这两种样式中最重要的部分是, 它强制您为代码编写测试。 我不是任何方法的 TDD 或 BDD 专家。我只是不知道自己的差异, 所以我调查了一下, 这是我想到了。这篇文章中的示例代码再次位于此存储库中: TDD vs bdd。","categories":[],"tags":[]},{"title":"","slug":"electron-functional-test-guide","date":"2018-08-18T05:24:08.902Z","updated":"2018-07-31T02:44:10.756Z","comments":true,"path":"2018/08/18/electron-functional-test-guide/","link":"","permalink":"https://blog.cmsax.com/2018/08/18/electron-functional-test-guide/","excerpt":"","text":"Electron 功能测试指南作者：蔡明师 日期：2018-07-30 [TOC] 概述在单元测试中，我们用到的是 Vue 官方给的 vue-test-utils 来控制、获取组件的运行状态，但在功能测试中，我们使用 Electron 官方提供的 Spectron 库。Spectron 暴露了以下十分有用的属性： client 属性，该属性是 WebdriverIO 中的 browser 对象，因此可以使用完全的 WebdriverIO 的 API 来操作、获取页面上的内容，实现譬如选择器、设置某一个 input 标签的值、设置某一个元素的属性、点击、滚动的诸多操作。 electron 属性，该属性可以看作对 electron 的引用，可以直接通过它来操作完整的 electron API 比如进程间通信、剪贴板操作等。 还有更多的属性，可以在其官方仓库中查看。 我们如何编写功能测试为确保每一个功能测试均有独立的环境，测试代码中包含了 beforeEach, afterEach这两个类似于 python 中的 startUp, tearDown的函数。 我们只需在代码目录的 ./test/e2e/specs/ 下新建名为 TEST_NAME.spec.js 的文件，并粘贴以下代码片段即可建立一个新的部分功能测试。 在测试中，项目使用的测试断言库是 chai，具体的 BDD 风格的断言参考官方文档即可。比如，我们期望页面上的某一个元素的值为N可以写成这样：先获取元素的值 value，然后 expect(value).to.eq(expectValue) 123456789101112131415161718import utils from '../utils'describe('Test handle stock pool indicators', function () &#123; beforeEach(utils.beforeEach) afterEach(utils.afterEach) it('can add normal stock pool indicator', () =&gt; &#123; let client = this.app.client // do something expect(SOMETHIGN).to.be.or.eq(SOMETHING) &#125;) it('can validate wrong stock pool indicator with non-numeric backtest amount', () =&gt; &#123; let client = this.app.client // do something expect(SOMETHIGN).to.be.or.eq(SOMETHING) &#125;)&#125;) 如何运行功能测试采用npm进行包管理的js程序在根目录都有一个 package.json 文件，其中 scripts中定义了可以执行的命令。对于其中的命令，在命令行/powershell 中运行 npm run SPECIFIC_SCRIPTNAME 即可运行。 如，功能测试 npm run e2e","categories":[],"tags":[]},{"title":"","slug":"electron-continuous-integration-guide","date":"2018-08-18T05:23:25.219Z","updated":"2018-07-17T08:24:46.695Z","comments":true,"path":"2018/08/18/electron-continuous-integration-guide/","link":"","permalink":"https://blog.cmsax.com/2018/08/18/electron-continuous-integration-guide/","excerpt":"","text":"Electron 持续集成指南作者：蔡明师 日期：2018-07-06 [TOC] 从总体上来看，配置 Electron 的自动化测试、部署环境主要需要解决两个问题： 自动测试，包括单元测试和功能测试，都需要直接运行一个虚拟的或者可被测试框架检测的 Electron 实例。而在 Linux 环境下， 配置步骤 下面的操作均在 Docker 的 Fedora 镜像上完成。已经配置好镜像，直接拉下来即可用。 docker pull windworship/npm-image 安装 wine32 太麻烦了，直接在已经安装好 wine32 的 fedora docker 镜像上进行以下操作即可。 安装xvfb，用于虚拟一个屏幕出来。在运行的时候，在命令后面加上一个 &amp; 即可让其在后台运行而不影响 stdin 1dnf install Xvfb 安装 electron 依赖，基本上在运行 electron 时报错什么就搜索什么，然后安装即可。 12345# 搜索dnf search &lt;package-name-without-space&gt;# 安装dnf install &lt;package-name-1&gt; &lt;name-2&gt; ... &lt;name-n&gt; -y 参考官方文档安装最新的8.x的nodejs 升级npm 在 docker 中安装 nodejs 和升级 npm 应当在同一个 layer 中，即应当放在同一个 RUN 命令中，以共享上下文环境。 以 root 权限安装 electron 配置/etc/machine-id为32位无分隔符的uuid echo asjkfls2323r2r23kj...2jk3 &gt; /etc/machine-id 启动Xvfb服务，在 ci 中应当放在 before-script 中。 Xvfb :99 &amp; 在新的bash中设置环境变量$DISPLAY=:99，并开始测试。在 ci 中应当放在 before-script 中。 export DISPLAY=:99 在 linux 环境下删除当前目录中的 node_modules 并重新 npm install 常见问题使用 wine 打包 win32 应用问题： rcedit.exe failed with exit code 193. wine: Bad EXE format 123456It seems that you have 32 bit wine bottle in your ~/.wine folder. In order to be able to run 64 bit programs, you need to setup another bottle for 64 bit applications:$ WINEARCH=win64 WINEPREFIX=~/.wine64 winecfgAfter that you can run programs specifying your newly created wine64 bottle:$ WINEPREFIX=~/.wine64 wine app.exe 在 Fedora 上安装 nodejs v8参考 nodejs 官方安装指南。 npm prune 阶段出错升级 npm 即可解决问题 1npm i -g npm 下载 temp-XXX-electron-win 等内容失败检查网络连接，或者调整安装顺序。 Permission Denied 相关增加参数 1npm i -g electron --unsafe-perm=true --allow-root npm install 报错升级 npm 1npm i npm -g 缺少运行 electron 的相关组件，先 npm clean 再 npm install 无法运行electron 找不到依赖包 安装 Xvfb 并尝试 按照提示，依次在 dnf 库中搜索相关包并安装 无法运行electron DBus 库出错提示无法读取 /etc/machine-id 因此创建该文件并写入32位无分隔符的任意UUID即可（预先设置一个字符串即可） 123echo 12fabasjfklafsdjfk...ajsdklfj &gt; /etc/machine-id# 或者输入标准的uuiduuid &gt; /etc/machine-id","categories":[],"tags":[]}]}